/*
 * (C) Copyright 1996-2013 ECMWF.
 *
 * This software is licensed under the terms of the Apache Licence Version 2.0
 * which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
 * In applying this licence, ECMWF does not waive the privileges and immunities
 * granted to it by virtue of its status as an intergovernmental organisation nor
 * does it submit to any jurisdiction.
 */

#include "fdb5/pmem/PMemIndex.h"
#include "fdb5/pmem/PMemBranchingNode.h"

namespace fdb5 {


//-----------------------------------------------------------------------------

//PMemIndex::PMemIndex(const Key &key, PMemBranchingNode& node) :
//    Index(key, path, offset, mode, type),
//    node_(node) {
//}
//
//
//PMemIndex::~PMemIndex() {
//}
//
//bool PMemIndex::get(const Key &key, Field &field) const {
//    NOTIMP;
//}
//
//
//void PMemIndex::open() {
//    // Intentionally left blank. Indices neither opened nor closed (part of open DB).
//}
//
//void PMemIndex::reopen() {
//    // Intentionally left blank. Indices neither opened nor closed (part of open DB).
//}
//
//void PMemIndex::close() {
//    // Intentionally left blank. Indices neither opened nor closed (part of open DB).
//}
//
//void PMemIndex::add(const Key &key, const Field &field) {
//    NOTIMP;
//}
//
//void PMemIndex::flush() {
//    // Intentionall left blank. Flush not used in PMem case.
//}
//
//void PMemIndex::entries(EntryVisitor &visitor) const {
//    NOTIMP;
//}
//
//void PMemIndex::print(std::ostream &out) const {
//    out << "PMemIndex[]";
//}
//
//
//std::string PMemIndex::defaulType() {
//    NOTIMP;
//}
//
//void PMemIndex::dump(std::ostream& out, const char* indent, bool simple) const {
//    NOTIMP;
//}


//-----------------------------------------------------------------------------

} // namespace fdb5
